%@HongminWu March 22,2017
% testing_all_learned_models_VS_1_trial
% 4 models + 1 observation
%1. load all the learned models in a cell named as 'learnedModel'
%2. load the testing trial
function static_test_state(trialID)
global  modelPath TESTING_DATASET_PATH TESTING_RESULTS_PATH PLOT_SAVE
global  METHOD ROBOT TASK STATE
global  TRAINING_SUCCESS_FAILURE TRAINING_SIM_REAL
global  TESTING_SUCCESS_FAILURE TESTING_SIM_REAL
global  THRESHOLD_PATH  TIME_STEP
global TRUE_POSITIVE  FALSE_NEGATIVE FALSE_POSITIVE TRUE_NEGATIVE
distAccuary = 0;

%initial parameters
COLOR                     = ['r', 'g', 'b','k'];
trainedModel              = {};
model                     = [];
thresholdcell                 = {};

expected_likelihood       = [];
c                         =  5;
gHandle_testing           = figure;
sensor                    = [];
temp_log_likelihood       = zeros(length(STATE),1);
total_log_likelihood      = [];
data_struct               = struct;
left                      = 0.1; 
bottow                    = 0.1; 
width                     = 0.8; 
heigh                     = 0.4;
trans                     = 0;
stateData                 = {};
[data, R_State, foldname] = load_one_trial(trialID,TESTING_DATASET_PATH);
data                      = data_preprocessing(data); % mean = 0 and covariance = Unit matrix
dataLen                   = [];

% step-1: find out the optimal model, load the data for each state, 
%         load the expected-log_likelihood, which generated by script 'calculate_state_threshold'
STATE_STATUS        = [];
for nState = 1 : length(STATE) 
    
    %find out the optimal model for each state, this step is achieved by function "calculate_state_threshold"
    thresholdPath  = strcat(THRESHOLD_PATH, char(STATE(nState)));
    if (exist(thresholdPath,'dir') == 0)
        disp('Please define the optimal model for each state before testing? Training -> Model Selection -> Testing');
        break;
    end
    
    cd(thresholdPath);
    % load the model selection
    model_select = load(strcat('OPTIMAL_MODEL_', char(STATE(nState)), '.mat'));
    %load the optimal likelihoods  
    likelihood                = load(strcat(THRESHOLD_PATH, char(STATE(nState)),'/','OPTIMAL_LIKELIHOOD_',char(STATE(nState)),'.mat')); 
    state_expected_likelihood = mean(likelihood.OPTIMAL_LIKELIHOOD);
    sigma                     = sqrt(var(likelihood.OPTIMAL_LIKELIHOOD));
    stateThreshold            = state_expected_likelihood - c * sigma;

    % Load Model for selected state. We will compare other observations with this.
    file                      = dir([strcat(modelPath,char(STATE(nState)),'/') strcat('*',char(model_select.OPTIMAL_MODEL),'.mat')]);
    optiModel                 = [];    
    optiModel                 = load(strcat(modelPath,char(STATE(nState)),'/',file.name));                                 %for initializating the 'meanmodel'
    trainedModel              = [trainedModel, {optiModel}];
    sData                     = data(:,R_State(nState):R_State(nState + 1));
    
    %align the threshold and the observed data
    aligLen                   = min(length(sData),length(stateThreshold)); 
    sData                     = spline(1:length(sData), sData, linspace(1,length(sData), aligLen)); %Resampling alignment
    stateThreshold            = spline(1:length(stateThreshold), stateThreshold, linspace(1,length(stateThreshold), aligLen)); %Resampling alignment
    state_expected_likelihood = spline(1:length(state_expected_likelihood), state_expected_likelihood, linspace(1,length(state_expected_likelihood), aligLen)); %Resampling alignment
    
    expected_likelihood       = [expected_likelihood, state_expected_likelihood];
    thresholdcell                 = [thresholdcell, {stateThreshold}];
    stateData                 = [stateData, {sData}];   
    dataLen = [dataLen, length(sData)-1];
end
    dataLen                   = [1, dataLen];
    dataLen                   = cumsum(dataLen);
    R_State                   = dataLen;
    
% step-2: calculate the cumlative log-likelihood for each state, and store in the 'stateLikelihood' array.
    stateLikelihood           = zeros(length(STATE),dataLen(end));
    obsModel                  = trainedModel{1}.obsModel;
    obsModelType              = trainedModel{1}.obsModel.type;
for nState = 1:length(STATE)
    disp(strcat('Testing:',char(STATE(nState))));
    sensor                        = stateData{nState};
    data_struct.obs               = sensor;
    data_struct.true_labels       = ones(1,size(sensor,2));
    data_struct.test_cases        = 1;
    data_struct.blockSize         = ones(1,size(sensor,2));
    data_struct.blockEnd          = 1:size(sensor,2);

    if strcmp(obsModelType,'AR')
        [X,valid]                 = makeDesignMatrix(data_struct.obs,obsModel.r);
        data_struct.obs           = data_struct.obs(:,find(valid));
        data_struct.X             = X(:,find(valid));
        data_struct.blockSize     = ones(1,size(data_struct.obs,2));
        data_struct.blockEnd      = cumsum(data_struct.blockSize);
        data_struct.true_labels   = data_struct.true_labels(find(valid));
    end
    
    % 
    % for state classification
    %
    %     for nModel = 1:length(trainedModel) %  the same data for different state model
    %         %testing the observed data for each learned model
    %         dist_struct               = trainedModel{nModel}.dist_struct; 
    %         theta                     = trainedModel{nModel}.theta;
    %         obsModel                  = trainedModel{nModel}.obsModel;
    %         obsModelType              = trainedModel{nModel}.obsModel.type;
    %         [testing_total_log_likelihood,...
    %             testing_neglog_c]     = observation_likelihood(data_struct,obsModelType,dist_struct,theta);       
    %         stateLikelihood(nModel,R_State(nState) + obsModel.r:R_State(nState + 1))     =  cumsum(testing_neglog_c); %
    %     end
    
    % 
    % for failure detection
    %
    dist_struct               = trainedModel{nState}.dist_struct; 
    theta                     = trainedModel{nState}.theta;
    obsModel                  = trainedModel{nState}.obsModel;
    obsModelType              = trainedModel{nState}.obsModel.type;
    [testing_total_log_likelihood,...
        testing_neglog_c]     = observation_likelihood(data_struct,obsModelType,dist_struct,theta);       
        stateLikelihood(nState,R_State(nState) + obsModel.r:R_State(nState + 1))     =  cumsum(testing_neglog_c); %
     
        current_log =  cumsum(testing_neglog_c); 
    %diff = current_log - thresholdcell{nState}(1:length(testing_neglog_c));
    diff = current_log(end) - thresholdcell{nState}(end);
    
    if  isempty(diff(find(diff < distAccuary)))
        STATE_STATUS = [STATE_STATUS, true];
    else
        STATE_STATUS = [STATE_STATUS, false];
    end 
end

switch (TESTING_SUCCESS_FAILURE)
    case 'SUCCESS'
        if  isempty(STATE_STATUS(find(STATE_STATUS == 0))) % all marked as true;
            TRUE_POSITIVE    = TRUE_POSITIVE + 1;
        else
            FALSE_NEGATIVE =  FALSE_NEGATIVE + 1;
        end
        TPR = (TRUE_POSITIVE/(TRUE_POSITIVE + FALSE_NEGATIVE));
        disp(strcat('TRUE_POSITIVE_RATE:',num2str(TPR*100), '%'));   
    case 'FAILURE'
        if  isempty(STATE_STATUS(find(STATE_STATUS == 0))) % all marked as true;
            FALSE_POSITIVE    = FALSE_POSITIVE + 1;
        else
            TRUE_NEGATIVE =   TRUE_NEGATIVE + 1;
        end   
        FPR = (FALSE_POSITIVE/(FALSE_POSITIVE + TRUE_NEGATIVE));
        disp(strcat('FALSE_POSITIVE_RATE:',num2str(FPR*100), '%'));
end


threshold = [];
for ithres = 1:length(thresholdcell)
    threshold = [threshold, thresholdcell{ithres}];
end

   %For plotting  
    FontSize   = 14;
    disp(strcat('Plotting! Please Wait'));
    subplot_1 = subplot(1,1,1,'Parent',gHandle_testing);
    fig_expected_likelihood = plot([1:length(expected_likelihood)] * TIME_STEP, expected_likelihood','m--','LineWidth',2,'Parent',subplot_1);
    hold on;
    fig_threshold = plot([1:length(threshold)] * TIME_STEP, threshold','c--','LineWidth',2,'Parent',subplot_1);     
    hold on;

    fig_leg = {};
    stateLikelihood(find(stateLikelihood == 0)) = NaN;
    for sIdx = 1 : size(stateLikelihood,1)
        title({'Cumulative Log-Likelihoods of Possible Sub-Tasks and Trained Model';...                                                                                                                        
              strcat('TrainingModels: ', METHOD,'-',ROBOT,'-',TASK,'-',TRAINING_SIM_REAL,'-', TRAINING_SUCCESS_FAILURE) ; ...
              strcat('TestingTask: '   , TESTING_SIM_REAL ,'\_', TESTING_SUCCESS_FAILURE ,'\_',char(foldname))     ;  ...
              });
        grid on;
        grid MINOR
        fig_leg{sIdx} = plot([1:length(stateLikelihood(sIdx,:))] * TIME_STEP,stateLikelihood(sIdx,:)',COLOR(sIdx),'LineWidth',2,'Parent',subplot_1);
        axis auto
        xlabel('Time(s)','FontName','Times New Roman','FontSize',FontSize)
        ylabel('Cumulative Log-Likelihood','FontName','Times New Roman','FontSize',FontSize,'Rotation',90)
        set(gca,'xtick',[0:3:(length(data)* TIME_STEP)]);
        gridxy(R_State(:,:) * TIME_STEP,'Linestyle','-','Color',[.5 .5 .5],'linewidth',2);
        hold on;
    end

%     legendEntries = [fig_expected_likelihood, fig_threshold, fig_leg{1}, fig_leg{2}, fig_leg{3}, fig_leg{4}];
%     h = legend(legendEntries,'Expected-Log\_likelihood of Each Sub-Task','Threshold of Each Sub-Task','Sub-Task:Approach','Sub-Task:Rotation','Sub-Task:Insertion','Sub-Task:Mating', 'Location','SouthWest');
%     set(h,'Fontsize',FontSize);
    %{
    %Evoluting data 
    subplot_2 = subplot(2,1,2,'position', [left bottow width heigh],'Parent',gHandle_testing);
    cla(subplot_2);
    plot(data(:,1:obsIdx)','Parent',subplot_2); % for animation
    grid on;
    grid MINOR
    gridxy(obsIdx,'Linestyle','-','Color',[.5 .5 .5],'linewidth',0.6);
    xlim([0  length(data)]);
    %}
%set(gHandle_testing,'PaperUnits','centimeters','PaperPosition',[14, 19, 10, 15],'PaperPositionMode','manual');
if (exist(TESTING_RESULTS_PATH,'dir') == 0)
    mkdir(TESTING_RESULTS_PATH);
end
if PLOT_SAVE
    cd (TESTING_RESULTS_PATH);
    saveas(gHandle_testing, strcat('_',foldname),'jpg');
end
end